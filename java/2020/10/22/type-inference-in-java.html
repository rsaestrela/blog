<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="robots" content="index,follow">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Type Inference in Java</title>
  <meta name="description" content="Type inference is a technique used by statically typed languages, where the compiler infers the types of variables using the context where they are declared....">
  <link rel="stylesheet" href="/blog/css/main.css">
  <link rel="canonical" href="https://estrela.me/blog/java/2020/10/22/type-inference-in-java.html">
  <link rel="alternate" type="application/rss+xml" title="estrela.me * blog" href="https://estrela.me/blog/feed.xml">
  <link rel="icon" href="/blog/favicon.ico" type="image/x-icon">
  <meta property="og:title" content="Raul Estrela">
  <meta property="og:site_name" content="Raul Estrela Blog">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://estrela.me/blog">
  <meta property="og:image" content="/assets/profile_image.png">
  <meta property="og:description" content="@rsaestrela personal website">
  <meta itemprop="name" content="Raul Estrela">
  <meta itemprop="description" content="@rsaestrela personal website">
  <meta itemprop="image" content="https://estrela.me/img/profile_image.png">
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-180685972-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-180685972-1');
</script>
</head>

  <body>
    <header class="header">
  <div class="wrapper">
    <a href="/blog/">
      <div class="profile-image"></div>
    </a>
    <div class="title">Thoughts written down, by Raul Estrela</div>
  </div>
</header>

    <header class="bar">
  <div class="wrapper">
    <span class="link-button">
      <a class="text-button" target="_blank" href="/blog/feed.xml">subscribe rss</a>
    </span>
    <span class="link-button">
      <a class="text-button" target="_blank" href="https://estrela.me">estrela.me</a>
    </span>
    <span class="link-button">
      <a class="text-button" target="_blank" href="https://github.com/rsaestrela">github</a>
    </span>
    <span class="link-button">
      <a class="text-button" target="_blank" href="https://www.linkedin.com/in/raulsilvaestrela/">linkedin</a>
    </span>
    <span class="link-button">
      <a class="text-button" target="_blank" href="https://dev.to/rsaestrela">dev.to</a>
    </span>
  </div>
</header>

    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Type Inference in Java</h1>
    <p class="post-meta"><time datetime="2020-10-22T00:00:00+00:00" itemprop="datePublished">Oct 22, 2020</time></p>
  </header>
  <div class="post-content" itemprop="articleBody">
    <p>Type inference is a technique used by statically typed languages, where the compiler infers the types of variables using the context where they are declared. Programming languages with sophisticated type systems tend to rely more on type inference to improve the readability of the code. For some, this proved to produce more concise code and increase productivity by adding some fun and less typing. Others might feel it’s worse because it removes useful information from the code and that makes it less maintainable. There are multiple opinions about it, but the truth is that writing without explicitly specifying types is trending up. There are some good examples of JVM languages with improved type systems that do this amazingly well (Groovy, Scala and more recently Kotlin), but it’s worth to note how type inference has been evolving in Java and to give an update on the latest features.</p>

<h3 id="javas-type-inference-system">Java’s Type Inference System</h3>

<p>As a traditional programming language, the Java type inference system has been evolving quite slowly in the last years. Although, Java always provided a very basic form type inference since the first version expressed by one of its main OOP features: inheritance. The subclassing mechanism is natively supported by a subtyping inference on classes.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">Object</span> <span class="n">sport</span> <span class="o">=</span> <span class="s">"football"</span><span class="o">;</span> <span class="c1">// sport is a String</span>
</code></pre>
</div>

<p>This very basic form of type inference was considerably improved in Java 5, when generic methods were introduced. The type inference system was then capable of inferring parameterized classes (type constructors), subtyping extension and wildcards. For example, instead of:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">sports</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="n">asList</span><span class="o">(</span><span class="s">"football"</span><span class="o">,</span> <span class="s">"tennis"</span><span class="o">);</span>
</code></pre>
</div>

<p>Since <code class="highlighter-rouge">asList</code> implements generics and returns a generic type <code class="highlighter-rouge">List&lt;T&gt;</code>, this type declaration can be easily inferred be the compiler:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">sports</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"football"</span><span class="o">,</span> <span class="s">"tennis"</span><span class="o">);</span>
</code></pre>
</div>

<p>In Java 7, the scope of this mechanism was slightly extended to infer type parameters of generic constructor invocations with <code class="highlighter-rouge">&lt;&gt;</code> (known as <em>diamond</em>). Later in 2014, Java 8 was shipped with type inference for lambda expressions. More recently, project Amber brought in Java 10 &amp; 11 groundbreaking type inference improvements, this time for method local and lambda expression parameters using the keyword <em>var.</em></p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">var</span> <span class="n">sport</span> <span class="o">=</span> <span class="s">"football"</span><span class="o">;</span> <span class="c1">// sport is a String</span>
</code></pre>
</div>

<p>In my opinion Java is evolving this aspect quite interestingly for a few reasons. It’s worth to note some of them.</p>

<h4 id="java-type-inference-is-not-forced">Java Type Inference is not forced</h4>

<p>Java does not enforce type inference. This is giving the programmer options and not obligations on when to specify types or let the compiler do that work. It may look a minor detail, but it’s an important point in language design when it comes to backward compatibility (one of Java greatest strengths) and gives some freedom and flexibility for the developer to decide the syntax that best suits the best.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">winners</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="n">asList</span><span class="o">(</span><span class="s">"first"</span><span class="o">,</span> <span class="s">"second"</span><span class="o">);</span> <span class="c1">//type manifest</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">winners</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"first"</span><span class="o">,</span> <span class="s">"second"</span><span class="o">);</span> <span class="c1">// inferred type</span>
</code></pre>
</div>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">losers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span> <span class="c1">// type manifest</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">losers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span> <span class="c1">// inferred type (diamond operator)</span>
</code></pre>
</div>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">teams</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span> <span class="c1">// inferred type (diamond operator)</span>
<span class="n">var</span> <span class="n">teams</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span> <span class="c1">// inferred type (local type inference)</span>
</code></pre>
</div>

<h4 id="java-type-inference-is-nothing-else-but-local">Java Type Inference is nothing else but local</h4>

<p>In opposition to other languages, type inference in Java is only local and only does one exact thing: local constraint solving. Instead of a more global approach, Java restricts this mechanism to a method, expression or statement - gathering constraints on unknown types and solving them at some point. There are multiple strategies (aka algorithms) to perform these operations in order to cover all edge cases. By design, applying this mechanism to local scopes can be a little bit restricting. On the other hand making types manifest mandatory outside local scopes appears to be a better solution in terms of maintainability (directly proportional to readability).</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">resumeMatch</span><span class="o">(</span><span class="n">Squad</span> <span class="n">squad</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">sendScores</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;());</span>
    <span class="n">publishSquad</span><span class="o">(</span><span class="n">squad</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">sendScores</span><span class="o">(</span><span class="n">ArrayList</span><span class="o">&lt;?&gt;</span> <span class="n">scores</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">scores</span><span class="o">;</span> <span class="c1">// DOES NOT COMPILE</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">publishSquad</span><span class="o">(</span><span class="n">var</span> <span class="n">squad</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// DOES NOT COMPILE</span>
    <span class="n">squad</span><span class="o">.</span><span class="na">publish</span><span class="o">();</span>
<span class="o">}</span>
</code></pre>
</div>

<h4 id="local-variable-type-inference-promotes-non-null-type-initialization">Local Variable Type Inference promotes non-null type initialization</h4>

<p>Local variable type inference delivered in Java 10 (improved in version 11 for lambda expression parameters) avoids null type initialization by design. And there’s a good reason for this - for local variables declared with <em>var</em>, the type inference system first computes the type of the initializer, which will be rejected if it is <em>null</em>. Hopefully this will contribute to more reliable code.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// DONT DO THIS</span>
<span class="kd">public</span> <span class="n">File</span> <span class="nf">getFileContent</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">File</span> <span class="n">file</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">file</span> <span class="o">=</span> <span class="n">readFile</span><span class="o">(</span><span class="s">"file.json"</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// SOME</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">file</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">File</span> <span class="nf">getFileContent</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">//var file = null; // DOES NOT COMPILE</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">readFile</span><span class="o">(</span><span class="s">"file.json"</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"Failed reading file"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<h4 id="local-variable-type-inference-is-less-restrictive-on-non-denotable-types">Local Variable Type Inference is less restrictive on non-denotable types</h4>

<p>When inferring local variables with <em>var</em> , the type can be rejected or special inference rules apply. This happens for non-denotable types. Non-denotable types are those types that can exist within the program, although there’s no way to explicitly write out the name for that type. A good example of rejection in <em>null</em> (mentioned before), but there are interesting cases of non-denotable types where the usage of <em>var</em> comes with advantages - anonymous classes. When assigning variables with <em>var</em> the type inference system will infer the type differently giving access to members that wouldn’t be available using the traditional notation.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">var</span> <span class="n">player</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"John"</span><span class="o">;</span>
    <span class="kd">final</span> <span class="kt">int</span> <span class="n">goals</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>
<span class="o">};</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"Player %s scored %s goals%n"</span><span class="o">,</span> <span class="n">player</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">player</span><span class="o">.</span><span class="na">goals</span><span class="o">);</span>
</code></pre>
</div>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">var</span> <span class="n">ball</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Ball</span><span class="o">();</span>
<span class="n">var</span> <span class="n">striker</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Striker</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Goal</span> <span class="nf">shoot</span><span class="o">(</span><span class="n">Ball</span> <span class="n">ball</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Goal</span><span class="o">(</span><span class="n">ball</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">Ball</span> <span class="nf">returnBall</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">ball</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">};</span>
<span class="n">var</span> <span class="n">ballReturned</span> <span class="o">=</span> <span class="n">striker</span><span class="o">.</span><span class="na">returnBall</span><span class="o">();</span>
</code></pre>
</div>

<h3 id="conclusion">Conclusion</h3>

<p>Compared to other features Java released in the last years, the latest improvements made in the type inference system were one of the most controversial. Local type inference in Java 10 proved this to be true as most people seemed reluctant and described this feature as something just to make Java more popular and trendy (C#, Scala or later Kotlin already had this feature) or as something that could encourage laziness and produce unreadable code. Some years after the release of this feature, the scenario is clear - like anything in programming, local variable inference requires good measure and adoption of <a href="https://openjdk.java.net/projects/amber/LVTIstyle.html">style guidelines</a>.  In the new Java release cycle, Project Amber quickly brought to Java something that the community was asking for a long time. As GraalVM (and Truffle!) is gaining popularity, I believe that some of the constraints at interpreter and compiler level will be easier to overcome and Java will bring new type system improvements, faster than ever.</p>


  </div>
  

</article>

      </div>
    </div>
    <footer class="site-footer">
  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col">
        <p class="copyright">All rights reserved © Raul Estrela 2021</p>
      </div>
    </div>
  </div>
</footer>

  </body>
</html>
